## 소개

이곳은 던파랜드를 개발하면서 했던 기술적 고민, 메인에서 다루지 않은 문제와 해결과정, 각종 에피소드를 기록한 곳입니다.

문제들을 해결하면서 어마어마한 시간을 쏟아 부었고 문제 해결 경험이 저에게 큰 자산이 되었습니다.

그래서 이 소중한 자산을 기록하는 것이 좋겠다고 생각하여 이곳에 기록합니다.

## 기술적 고민

- 서로 독립적인 data fetch 요청을 보낼 땐 응답 속도를 빠르게 하기 위해 Promise.all로 병렬처리하기
  * async/await 구문은 앞의 작업이 끝나면 그 결과를 가지고 뒤에서 작업하는 방식이다. 그래서 앞의 작업 결과와 상관없는 비동기 작업들은 굳이 앞의 작업을 기다린 후에 실행할 필요가 없다. 즉, 서로 독립적인 비동기 작업들은 동시에 요청을 보내고 최소한으로 기다리는 것이 좋다.

- 서버사이드렌더링은 서버에서 렌더링을 미리 완료하고 그 결과를 클라이언트에 보낸다. 그런데 서버에서 렌더링할 때 필요한 정보를 받아오는 작업을 서버 측에서 할 수 없을 때가 있다. 예를 들어, localStorage에 접근할 수 없다. 이럴 땐 어떻게 해야 할까?
  * 클라이언트 사이드에서 어떤 작업을 하려면 useEffect를 이용한다. useEffect는 렌더링이 완료된 후 실행되는 함수이다. 그러면 useEffect 안에서 클라이언트의 작업을 수행하고 렌더링할 정보를 갱신해서 리렌더링 시켜야 한다. 즉, 상태를 하나 정의하고 일단 빈 값으로 초기화시킨 후 렌더링하도록 해두고 useEffect에서 받은 정보를 상태에 저장한다.
  * 이렇게 하면 첫 렌더링이 끝난 후에 정보를 받는 작업을 하고 이것을 리렌더링하기 때문에 그 정보의 렌더링만 느리다는 단점이 있다. 던파랜드에서도 모험단 정보를 읽어오는 부분만 속도가 느려서 렌더링이 어색하다. 그래서 아쉬움이 남는다.

- 게시글 삭제, 댓글 삭제 시에 bootstrap의 Modal을 이용해서 삭제할지 한 번 더 되묻는다. 이 때 확인 버튼을 누르는 것을 어떻게 감지하고 삭제 명령을 내릴 것인가? data fetch와 같은 비동기 명령은 응답을 기다리다가 받은 응답을 가지고 처리하면 되니까 문제가 되지 않지만, 이 경우 확인 버튼을 누르는 것을 비동기적으로 감지할 수 없다.
  * 삭제 명령 시 Modal을 생성하고 나서 확인 버튼을 누르는 것을 기다리지 않는다. 만약 Modal에서 어느 영역을 누르는지 이벤트핸들링을 직접 한다면 복잡한 일이 된다.
  * 대신, 상태 두 개를 새롭게 정의한다. 삭제 명령 시 삭제 대상 고유 id를 상태 하나에 담는다. 그리고 Modal에서 확인 버튼을 누르면 상태 하나를 true로 만들어준다. Modal에서 확인 버튼을 누르면서 상태가 변경되었으므로 리렌더링이 되고 useEffect가 실행된다. 이때, 두 상태에 삭제 대상 고유 id가 들어있으면서 true이면 대상을 delete하는 요청을 보내고 두 상태를 원래대로 돌려놓는다.

- 


## 메인에서 다루지 않은 문제들과 해결과정

- ㅇㅇ


## 에피소드

- aws rds에서 요금이 60달러 청구됐던 스토리

ㅇㅇㅇ

- 깃허브에 env파일까지 커밋돼서 메일이 쏟아지고 aws 계정이 경고받았던 스토리

ㄷㄷㄷㄷㄷㄷ


## 느낀 점

ㅇㅇㅇㅇ
