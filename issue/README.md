## 소개

이곳은 던파랜드를 개발하면서 했던 기술적 고민, 메인에서 다루지 않은 문제와 해결과정, 각종 에피소드를 기록한 곳입니다.

문제들을 해결하면서 시간을 엄청나게 쏟아 부었고 그 과정과 경험은 저의 큰 자산이 되었습니다.

그래서 이 소중한 자산을 기록하는 것이 좋겠다고 생각하여 이곳에 기록합니다.

## 기술적 고민

- 서로 독립적인 data fetch 요청을 보낼 땐 응답 속도를 빠르게 하기 위해 Promise.all로 병렬처리하기
  * async/await 구문은 앞의 작업이 끝나면 그 결과를 가지고 뒤에서 작업하는 방식이다. 그래서 앞의 작업 결과와 상관없는 비동기 작업들은 굳이 앞의 작업을 기다린 후에 실행할 필요가 없다. 즉, 서로 독립적인 비동기 작업들은 동시에 요청을 보내고 최소한으로 기다리는 것이 좋다.

![Screenshot_360](https://user-images.githubusercontent.com/59219773/140921718-56a8f620-2aa7-4e2f-bc5b-c759a72be678.png)


- 서버사이드렌더링은 서버에서 렌더링을 미리 완료하고 그 결과를 클라이언트에 보낸다. 그런데 서버에서 렌더링할 때 필요한 정보를 받아오는 작업을 서버 측에서 할 수 없을 때가 있다. 예를 들어, localStorage에 접근할 수 없다. 이럴 땐 어떻게 해야 할까?
  * 클라이언트 사이드에서 어떤 작업을 하려면 useEffect를 이용한다. useEffect는 렌더링이 완료된 후 실행되는 함수이다. 그러면 useEffect 안에서 클라이언트의 작업을 수행하고 렌더링할 정보를 갱신해서 리렌더링 시켜야 한다. 즉, 상태를 하나 정의하고 일단 빈 값으로 초기화시킨 후 렌더링하도록 해두고 useEffect에서 받은 정보를 상태에 저장한다.
  * 이렇게 하면 첫 렌더링이 끝난 후에 정보를 받는 작업을 하고 이것을 리렌더링하기 때문에 그 정보의 렌더링만 느리다는 단점이 있다. 던파랜드에서도 모험단 정보를 읽어오는 부분만 속도가 느려서 렌더링이 어색하다. 그래서 아쉬움이 남는다.

- 게시글 삭제, 댓글 삭제 시에 bootstrap의 Modal을 이용해서 삭제할지 한 번 더 되묻는다. 이 때 확인 버튼을 누르는 것을 어떻게 감지하고 삭제 명령을 내릴 것인가? data fetch와 같은 비동기 명령은 응답을 기다리다가 받은 응답을 가지고 처리하면 되니까 간단하지만, 이 경우 확인 버튼을 누르는 것을 비동기적으로 감지할 수 없다.
  * 삭제 명령 시 Modal을 생성하고 나서 확인 버튼을 누르는 것을 기다리지 않는다. 만약 Modal에서 어느 영역을 누르는지 이벤트핸들링을 직접 한다면 복잡한 일이 된다.
  * 대신, 상태 두 개를 새롭게 정의한다. 삭제 명령 시 삭제 대상 고유 id를 상태 하나에 담는다. 그리고 Modal에서 확인 버튼을 누르면 상태 하나를 true로 만들어준다. Modal에서 확인 버튼을 누르면서 상태가 변경되었으므로 리렌더링이 되고 useEffect가 실행된다. 이때, 두 상태에 삭제 대상 고유 id와 true가 들어있으면, 대상을 delete하는 요청을 보내고 두 상태를 원래대로 돌려놓는다.

![Screenshot_361](https://user-images.githubusercontent.com/59219773/140921823-ea1993cb-6228-46a4-8746-2299f2d2ef74.png)


- 대댓글을 어떻게 정의할 것인가? 보통의 댓글과 어떤 방식으로 구별할 것인가? 렌더링할 땐 어떻게 원댓글의 바로 밑에 오는 순서로 만들 것인가?
  * 대댓글도 댓글의 일종으로서 작성자, 내용, 작성 시간 등 대부분의 속성이 동일하고, 게시글에서 댓글 수를 셀 때 대댓글도 댓글과 같이 세므로 같은 데이터베이스 모델로 정의한다.
  * 그러면 원댓글이 대댓글과 갖는 관계는 self relation이 된다. 모델 설계에서 1?:n? 관계를 갖도록 해서 원댓글 밑에 다수의 대댓글을 달 수 있도록 했다.
  * 렌더링할 땐 먼저 원댓글 배열을 map으로 하나씩 렌더링한다. 이때 원댓글의 대댓글 배열에 원소가 있으면 원댓글 밑에 즉시 대댓글을 map으로 쭉 렌더링하도록 했다.

![Screenshot_362](https://user-images.githubusercontent.com/59219773/140921844-e4cb45a3-92e3-4237-b5bc-c6af706494eb.png)


- 대댓글이 달린 댓글을 삭제하면 어떻게 처리할 것인가?
  * 다른 커뮤니티 사이트의 경우 삭제한 댓글과 대댓글은 전부 그대로 두고 삭제한 댓글의 내용만 '삭제된 댓글입니다'로 보이게 처리한다. 그렇다는건 데이터베이스에서 row를 삭제 처리한 것이 아니고 삭제 처리 여부를 나타내는 col 하나를 true로 설정한 것이다.
  * 던파랜드의 경우 대댓글이 달린 댓글을 삭제할 수 없게 만들었다. 게시판이 그다지 공격적인 성격을 띄는 것도 아니고, 댓글을 삭제할 수 없도록 만들면 사용자들이 더 조심해서 댓글을 쓰게 만드는 효과가 있을 것이라 생각했다.

- 대댓글 작성하기 form이 동시에 다수 존재하면 작성하는 form의 ref를 어떻게 참조할 것인가?
  * 대댓글 작성하기 form을 연 만큼의 ref를 생성해서 각각 참조시키도록 만들 수도 있다.
  * 하지만 대댓글을 동시에 작성하는 상황은 거의 없으므로 대댓글 작성 form이 동시에 두 개 이상 존재할 수 없도록 했다. 그래서 useRef는 한 번으로 충분했다.

![Screenshot_369](https://user-images.githubusercontent.com/59219773/140923009-270c723d-46bc-4490-97d9-b3b30cd1dc80.png)


- prisma의 페이지네이션을 이용할 때 offset 방식이 적절한 곳과 cursor 방식이 적절한 곳이 어디일까?
  * offset 방식은 현재 내 위치에 상관없이 정적으로 데이터를 찾는다. 그래서 게시판이나 검색 결과에서 n번 째 페이지를 찾을 때 유용하다.
  * 반면 cursor 방식은 현재 내 위치를 기준으로 데이터를 찾는다. 그래서 게시글에서 이전 n개 게시글, 이후 n개 게시글을 찾을 때 유용하다.

![Screenshot_370](https://user-images.githubusercontent.com/59219773/140923370-1339fd84-0f89-4c9b-a0af-fdfb8f29c779.png)



## 메인에서 다루지 않은 문제들과 해결과정

- 게시글 페이지에 접속하면 렌더링이 무한히 반복됨
  * 원인: useEffect 안에서 상태를 변경시키고, dependency에 그 상태가 포함되어 있어서 다시 렌더링 되었음. 렌더링되면서 useEffect가 다시 실행되고 그것이 또 렌더링을 유발하면서 무한히 반복됨.
  * 해결: 복잡했던 useEffect 내부를 분리시키고 dependency도 분리시켜서 렌더링이 렌더링을 유발하는 것을 막음.

- 게시글에서 다른 게시글 페이지로 이동해도 toast ui viewer가 처음 컨텐츠만 계속 보여주고 내용이 바뀌지 않음.
  * 원인: toast ui viewer의 initialValue 속성에 값을 한번 할당해주면 그 값이 변경되어도 viewer가 갱신되지 않음.
  * 해결: 페이지를 이동할때마다 viewer를 제거하고 다시 렌더링하도록 만듦.

![Screenshot_371](https://user-images.githubusercontent.com/59219773/140923676-75114fe6-061c-4f4e-84e8-67842e7d483d.png)


- prisma client를 통해 데이터베이스 쿼리로 요청을 보냈으나 클라이언트에선 불가능하다고 뜸.
  * 원인: 데이터베이스 접근은 클라이언트에서 직접 할 수 없음. 먼저 서버에 접근하고 서버에서 데이터베이스와 통신해야 함.
  * 해결: Next.js에서 제공하는 기능인 api 엔드포인트를 이용함. 클라이언트에서 api 서버에 요청을 보내면 api 서버에서 prisma db와 통신하고 다시 응답을 클라이언트로 보내주도록 만듦.

- prisma schema 설계 시 두 모델 사이에 relation을 두 개 이상 맺었더니 빨간 밑줄이 그어짐.
  * 원인: relation이 두 개 이상이 되면 두 데이터 사이에 어떤 relation으로 이어졌는지 구분이 불가능해짐.
  * 해결: relation에 이름을 지정해주면 disambiguate하여 어떤 relation에 해당하는지 구분이 가능해짐.

![Screenshot_363](https://user-images.githubusercontent.com/59219773/140923572-eb644ee6-80f2-40e1-9ad5-5916b7480e70.png)


- prisma schema에서 실수로 넣은 @unique 속성을 지우고 다시 db push해도 속성이 그대로 남아있음.
  * 원인: 버그인 것으로 추정함.
  * 해결: 그 속성을 완전히 지우고 db push 한 후 다시 속성을 만들어주고 db push 함.

- 로그인을 시도하면 prisma에서 table이 존재하지 않는다는 에러를 발생시킴.
  * 원인: next-auth와 연동되는 prisma/client 버전은 2버전까지만인데 최신 버전인 3.3.0 버전을 이용하고 있었음.
  * 해결: prisma/client 버전을 다운그레이드 함.

![Screenshot_364](https://user-images.githubusercontent.com/59219773/140923795-cabed23d-071e-43b0-9214-6166477cf2b9.png)


- 개발 땐 잘 되던 로그인이 배포에서만 되지 않음.
  * 원인: vercel을 통해 배포했는데 앱 설정에서 직접 환경변수를 하나하나 작성해줘야 함.
  * 해결: 필요한 환경변수를 모두 작성함.

![Screenshot_365](https://user-images.githubusercontent.com/59219773/140923873-5f1068e0-fa4f-44a8-bfe5-c1ac32873352.png)


- 문자열 내의 \n이 렌더링에서 개행이 아니라 띄어쓰기로 나타남
  * 해결: css 속성 white-space에 pre-line을 할당해 줌.

- toast ui editor를 import해서 사용하려는데 not defined 에러가 뜸.
  * 원인: toast ui editor는 Next.js의 서버사이드렌더링 환경에서 로드될 수 없음.
  * 해결: Next.js에서 제공하는 동적 임포트를 통해 서버사이드렌더링에서 로드되지 않게 설정해줌.

![Screenshot_366](https://user-images.githubusercontent.com/59219773/140923894-6efbfe3b-14cf-4f64-b40c-eaed6180f7b4.png)


- toast ui editor가 리액트 컴포넌트로 인식되지 않음.
  * 원인: toast ui editor를 동적 임포트하면서 변수에 저장했을 때 Camel Case로 이름을 작성함. 리액트 컴포넌트가 컴포넌트로 인식되려면 이름이 꼭 Pascal Case로 작성되어야 함.
  * 해결: 변수명을 Pascal Case로 수정함.

- 한 페이지에서 popper를 두 개 이상 사용할 수 없음.
  * 원인: usePopper는 한 컴포넌트 당 한 개 까지만 이용할 수 있음.
  * 해결: popper를 이용하는 요소를 다른 파일로 분리해서 각 컴포넌트 안에서 usePopper를 이용함.

![Screenshot_367](https://user-images.githubusercontent.com/59219773/140923922-95309c73-613d-4ec8-afe7-4655df40b6b8.png)


- aws rds의 데이터베이스와 연결되지 않음.
  * 원인: 데이터베이스 주소에 들어가는 정확한 사용자명을 찾을 수 없었음. 암호는 데이터베이스 수정에서 설정 가능했지만 이름은 설정 불가능해서 aws 계정명일 것으로 유추했음.
  * 해결: 데이터베이스 상세 정보 가운데 root 사용자명이 admin으로 적혀 있었고 이것이 데이터베이스 계정명이었음.

![Screenshot_368](https://user-images.githubusercontent.com/59219773/140923937-48b6700e-3428-4456-832d-289c9e3b2616.png)



## 에피소드

- aws rds에서 요금이 60달러 청구됐던 에피소드

앱을 배포해서 사용하려면 로컬 데이터베이스 대신 데이터베이스 서버가 필요했습니다. 그래서 찾아보다가 aws rds라는 관계형 데이터베이스의 존재를 알게 되었습니다. aws에 새로 가입하면 프리 티어 유저로 자동 등록되어 aws rds를 1년 동안 무료로 이용할 수 있었습니다. 그래서 회원가입을 하고 프리 티어 rds 링크에 들어가서 데이터베이스를 생성했습니다. 

![Screenshot_373](https://user-images.githubusercontent.com/59219773/140925131-9260e6d7-7839-4752-ae8f-07a9f1c611c9.png)


프리 티어로 무료로 이용할 수 있는 데이터베이스는 정해져 있었습니다. 하지만 이에 대한 설명이 너무 작게 되어있어서 저는 알아채지 못했습니다. 그래서 데이터베이스를 생성할때 목록 중 좋아보이는 AURORA PostgresQL 엔진을 선택했습니다. 선택했던 엔진은 on demand 요금제여서 시간 당 0.313달러가 청구되는 엔진이었습니다.

![Screenshot 2021-11-09 at 16 50 36](https://user-images.githubusercontent.com/59219773/140925158-8f39c0e4-d5c1-4230-81c2-3289137bde93.jpg)


앞서 상기한 문제 중 마지막 문제인 aws rds 연결 문제를 해결하느라 한참 구글 검색을 하고 있을 때였습니다. 특이하게 aws rds를 검색하면 나오는 연관 검색어에 aws rds 요금이 상위 결과에 있었습니다. 조금 특이하다고 생각해서 검색해봤습니다. 검색 결과 상위에 한글로 된 국내 블로그 글이 많았고 제목이 aws rds에서 나도 모르게 빠져나가는 요금 막기 였습니다.

글은 요금이 청구되는 aws의 서비스들을 삭제해야 돈이 나도 모르게 빠져나가지 않는다는 내용이었습니다. 글을 보고 즉시 aws에 접속해 결제 대시보드를 들어가보니 이미 60달러나 청구되어있는 상태였습니다. 이 때 당시는 데이터베이스를 생성한지 5일 정도 지난 뒤였습니다.

이걸 보자마자 청구 상세 내역을 확인했습니다. 다른 청구 내역은 없고 aws rds에서만 60달러가 청구되어 있었습니다. 즉시 요금이 더 청구되는 것을 막기 위해 rds에 접속해 데이터베이스를 중지했습니다. 그 후 한참을 검색으로 알아본 결과 정해진 데이터베이스를 이용해야만 프리 티어가 적용된다는 것을 알았습니다.

취업준비생에게 60달러는 엄청나게 큰 지출이었습니다. 게다가 개발 중인 앱이라 데이터베이스 사용량이 거의 없다시피 해서 필요없는 지출이었습니다. 이 청구를 취소할 방법이 없는지 검색으로 한참을 알아봤습니다. 그러다 블로그 글 중에 문의로 환불 받은 글을 보고 희망을 가졌습니다.

구글 번역기에 들어가서 환불을 요청하는 글을 썼습니다. 취업준비생이고 공부를 위해 데이터베이스를 생성했으며 프리 티어를 통해 무료로 이용하려 했다고 어필했습니다. 상황을 자세하게 설명했고 청구 취소 요구를 확실하게 명시했습니다. 그리고 번역기가 해준 번역글을 문의로 제출했습니다.

![Screenshot_372](https://user-images.githubusercontent.com/59219773/140925359-a6ab28cd-ba47-446d-85f4-bf71278bd7b3.png)


바로 다음 날 메일로 답장이 왔습니다. 저에게 청구를 막는 조치를 취하고 요금 알림 서비스를 등록하는 것을 요구했습니다. 그래서 요구하는대로 모두 하고 꼼꼼하게 삭제 할 수 있는건 모두 삭제하고 문의에 답장을 보냈습니다. 그러자 그 다음 날 메일이 왔습니다. 카드 결제 시점에 결제를 취소하도록 해주겠다는 내용이었습니다. aws에서 관대하게 환불해줘서 정말 다행이었습니다.

![Screenshot_359](https://user-images.githubusercontent.com/59219773/140925446-b4b4982c-4404-44a3-859c-d0e777ca9ecb.png)


카드 결제 취소라 결제 대시보드 청구 내역은 그대로 보입니다. 혹시 환불 문제를 겪고 계신 분은 참고하세요.

그 후 프리 티어가 적용되는 MySQL 데이터베이스를 만들어서 던파랜드와 연동했습니다. 프리 티어 db는 용량이 비교적 작지만 던파랜드 db로 쓰기엔 충분한 것 같습니다. 이제 요금 청구도 더이상 되지 않습니다.


- 깃허브에 액세스 키가 담긴 env파일까지 커밋돼서 메일이 쏟아지고 aws 계정이 경고받았던 에피소드




## 추가 느낀 점


개발하면서 소모한 전체 시간 중 상당한 비중을 문제 해결법을 찾는데 썼습니다.

위엔 원인을 간략하게 정리했지만 문제를 처음 마주했던 상황에선 원인이 파악되지 않은 상태에서 해결법을 사방팔방으로 찾느라 엄청나게 많은 시간을 썼고 고생을 많이 했습니다.

토이 프로젝트나 클론 코딩은 문제를 마주칠 일도 없고 코드 작성 때 자신만의 생각이나 고민이 반영되지 않는다는 아쉬움이 있습니다.

하지만 이렇게 혼자만의 힘으로 공부하고 개발하며 배포까지 하면서 구현 과정 중에 기술적 고민도 하고 다양한 문제를 해결하는 경험 통해 많은 걸 배웠습니다.

특히 문제의 원인이 정말 다양하고 이에 따른 해결 방법도 정말 다양하다는 것을 체감했습니다.

아쉬운 점이 있다면 혼자 개발하느라 기능 구현만 해도 시간이 오래 걸린다는 점, 그리고 이때문에 최적화에 신경쓸 겨를이 없다는 점, 그리고 직업별 데미지 계산 로직을 아직 구현하지 못했다는 점입니다.

하지만 사이트 개발을 진행하고 운영하면서 꾸준히 새로운 기능을 추가하고 사용자의 피드백을 수용할 계획입니다.

웹사이트를 혼자만의 힘으로 개발하면서 어려움을 많이 겪었지만 그만큼 많이 성장했습니다.

특히 새로운 기술을 학습하고 프로젝트에 적용하는 경험을 통해 빠르게 변화하는 기술 트렌드에 잘 적응할 수 있는 능력을 길렀습니다.

또한 다양한 문제 해결 경험을 통해 실제 개발 과정에서 마주하는 문제를 해결하는 능력도 길렀습니다.

이 소중한 경험들을 거치며 한층 더 개발자로서 성장함을 느꼈습니다.
